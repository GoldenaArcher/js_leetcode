# 二分算法原理及复杂度详解

binary search，常见的翻译有二分查找、二分搜索、折半搜索(这用的名词是 half-interval search)、对数搜索(这里用的名词是 logarithmic search)，是一种非常常见并且应用范围也比较广泛的搜索算法。

之前曾看到过一个说法：<q>凡是有序，皆是二分</q>，大概也能说明二分搜索的应用之广泛了。

## 二分搜索的基础原理

二分可以被用于查找 **有序数组** 中的某一个特定元素，其工作原理是查找一个 _既定值，target_ 从 **数组, arr** 的 **中点，mid** 开始查找，判断 $arr[mid]$ 的值，存在以下三种情况：

1. 如果 $target = arr[mid]$，则找到 _target_，直接返回 **mid**
2. 如果 $target > arr[mid]$，则代表 _target_ 坐落于 $[0...mid)$ 区间
3. 如果 $target < arr[mid]$，则代表 _target_ 坐落于 $(mid...arr.length)$ 区间

这种每迭代一次就会将可选项的数量折半，也是折半搜索名词的来源。

这里也会应用到双指针去确认搜索的区间，关于双指针的知识点细节可以看这里：[双指针总结](https://goldenaarcher.blog.csdn.net/article/details/118137704)。

### 二分的基础案例

以一个数组作为案例去进行二分查找的步骤，_目标值 target_ 为 1，数组为：

<table>
<tr>
<td>1</td>
<td>4</td>
<td>10</td>
<td>12</td>
<td>17</td>
<td>18</td>
<td>21</td>
<td>25</td>
</tr>
</table>

1. 确认 _最大值_ ，_最小值_ 和 _中点_

   这里*最大值* 是 $arr.length - 1$，也就是 7，_最小值_ 是数组的起点长度，也就是 0，_中点_ 的计算稍微麻烦一些—— $(0+7) \div 2 = 3.5$，这里会进行向下取整，所以 _中点_ 为 3。

    <table>
   <tr>
   <td bgColor='yellow'>1</td>
   <td>4</td>
   <td>10</td>
   <td bgColor="blue">12</td>
   <td>17</td>
   <td>18</td>
   <td>21</td>
   <td bgColor='yellow'>25</td>
   </tr>
   </table>

   对比 _target_ 和 $arr[mid]$，明显能够看出 $1 < 12$，所以在下一个迭代中可以将最大值更新为 $mid - 1$。

2. 更新 _最大值_ ，_最小值_ 和 _中点_

   这里*最大值* 是 $mid - 1$，也就是 2，_最小值_ 依旧是数组的起点长度，也就是 0，_中点_ 就为 1。

    <table>
   <tr>
   <td bgColor='yellow'>1</td>
   <td bgColor="blue">4</td>
   <td bgColor='yellow'>10</td>
   <td >12</td>
   <td>17</td>
   <td>18</td>
   <td>21</td>
   <td >25</td>
   </tr>
   </table>

   对比 _target_ 和 $arr[mid]$，明显能够看出 $1 < 4$，所以在下一个迭代中可以将最大值更新为 $mid - 1$。

3. 更新 _最大值_ ，_最小值_ 和 _中点_

   这里*最大值* 是 $mid - 1$，也就是 1，_最小值_ 依旧是数组的起点长度，也就是 0，_中点_ 就为 0.5 向下取整，还是 0。

   <table>
   <tr>
   <td bgColor='purple'>1</td>
   <td bgColor="yellow">4</td>
   <td>10</td>
   <td >12</td>
   <td>17</td>
   <td>18</td>
   <td>21</td>
   <td >25</td>
   </tr>
   </table>

   鉴于 红+蓝=紫，所以这里将 1 的颜色更新成紫色，表示这既是起点，也是中点。

   继续对比 _target_ 和 $arr[mid]$，已经找到了对应值，便可以直接返回 mid 作为 index 了。

这就是一个完整的二分搜索的流程。

## 二分搜索的复杂度

接下来会对时间复杂度和空间复杂度进行分析。

### 空间复杂度

空间复杂度是很简单的，根据上面的流程可以得知，在整个二分搜索的过程中，只需要额外存储三个变量：_最大值_ ，_最小值_ 和 _中点_，也因此，空间复杂度是常量 $O(1)$。

### 时间复杂度

时间复杂度是 $O(log(n))$，其计算方法会稍微复杂一些，现在就开始从头分析。

已知数组的长度为 $n$，每一次数组的长度都会折半，一直到数组长度为 1：

$n, \frac{n} {2}, \frac{n} {4}, ... 1$

所以又可以理解成：

$n \times (\frac{1}{2})^k = 1$

即，$n$ 乘以 $\frac{1}{2}$ 的 $k$ 次方后的值为 1。这个方程式再简化一下就能得到：

$n \times \frac{1}{2^k} = 1$

最后得出：

$n = 2^k$

最后应用对数公式，自然能够得出：

$k = \log_2n$

而在算法中计算空间复杂度和时间复杂度时，是可以忽略掉对数的底的这些常数的，因此时间复杂度也就可以缩写成 $log(n)$。
